---
title: "[Python] 백준 13549 - 숨바꼭질 3"
excerpt: "수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 0초 후에 2*X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오."

categories:
  - 알고리즘
tags:
  - []

permalink: /algorithm/BOJ13549/

toc: false
toc_sticky: false

date: 2023-06-16
last_modified_at: 2023-06-16
---

## [문제](https://www.acmicpc.net/problem/13549)

수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 0초 후에 2*X의 위치로 이동하게 된다.

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

***

## 입력
첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.

## 출력
수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.

***

## 예제

![image](https://github.com/JS042/cs231n/assets/84077022/b7ebdeec-6068-485c-b711-5f601df849c8)


***

## 풀이
- BFS문제, 간단한 문제인 줄 알았으나 순간이동(X*2)와 걷기(X-1,X+1) 순서가 매우 중요했음
- 최초 방문이 최소 경로가 되려면 가장 빠른 순간이동(X*2) 먼저 탐색
- 그 다음 걷기로만 갈 수 있는 위치인 X-1 먼저 탐색, 마지막으로 X+1
- 반례 살펴보면 빠른 이해 가능
- 반례: `(5,5) -> 0`, `(1,2) -> 0`, `(4,6) -> 1`

<br/>
## 코드

```python
# 걷기 -> X+1, X-1
# 순간이동 -> X*2

from collections import deque
n,k = map(int, input().split())
find = [-1] * 100001
find[n] = 0
deq = deque([n])

while deq:
    x = deq.popleft()
    
    if x == k:
        print(find[k])
        break

    # 순서 중요!!
    for nx in [x*2,x-1,x+1]: 
        if 0 <= nx <= 100000:
            if find[nx] == -1:
                deq.append(nx)
                
      # 순간이동 아닐 때는 이전 위치 값 +1
                if nx != x*2:
                    find[nx] = find[x]+1

      # 순간이동일 때는 이전 위치 값
                else:
                    find[nx] = find[x]
```
